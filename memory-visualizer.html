<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>C++ Memory Visualizer (interactive)</title>
<style>
  :root{--bg:#0f1724;--card:#0b1220;--accent:#60a5fa;--muted:#94a3b8;--green:#10b981}
  body{margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,Arial;background:linear-gradient(135deg,#071124 0%, #081426 100%);color:#e6eef8}
  header{padding:18px 24px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;gap:16px;align-items:center}
  h1{font-size:18px;margin:0}
  .wrap{display:flex;gap:18px;padding:18px}
  .panel{background:rgba(255,255,255,0.03);padding:14px;border-radius:12px;flex:0 0 360px}
  .viz{flex:1;padding:12px;display:flex;flex-direction:column;gap:12px}
  .area{display:flex;gap:12px}
  .block{background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));padding:12px;border-radius:8px}
  button{background:transparent;border:1px solid rgba(255,255,255,0.08);padding:8px 10px;border-radius:8px;color:var(--accent);cursor:pointer}
  .controls{display:flex;flex-wrap:wrap;gap:8px}
  .stack, .heap{flex:1;min-height:320px;background:rgba(255,255,255,0.02);border-radius:10px;padding:12px;position:relative;overflow:auto}
  .title{font-weight:600;color:var(--muted);font-size:13px;margin-bottom:8px}
  .frame{border-radius:8px;padding:8px;margin:6px 0;background:rgba(255,255,255,0.04);position:relative;transition:transform .35s ease,opacity .25s}
  .frame.small{padding:6px;font-size:13px}
  .cell{display:flex;justify-content:space-between;font-family:monospace;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.01);margin:6px 0}
  .addr{color:var(--muted);font-size:12px}
  .pointer-line{stroke:rgba(96,165,250,0.9);stroke-width:2;marker-end:url(#arrow)}
  .legend{font-size:13px;color:var(--muted)}
  .log{height:120px;overflow:auto;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;font-family:monospace;font-size:13px}
  .sample-btn{background:var(--accent);color:#04243b;border:none}
  .small-input{width:80px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  footer{padding:12px;color:var(--muted);font-size:13px}
  @media(max-width:900px){.wrap{flex-direction:column}.panel{width:100%}}
</style>
</head>
<body>
<header>
  <h1>C++ Memory Visualizer — Interactive (single-file demo)</h1>
  <div style="margin-left:auto;color:var(--muted);font-size:13px">Designed to demonstrate stack vs heap, pointers and call frames</div>
</header>
<div class="wrap">
  <div class="panel block">
    <div class="title">Controls</div>
    <div class="controls">
      <button id="pushFrame">Push stack frame (call)</button>
      <button id="popFrame">Pop stack frame (return)</button>
      <button id="allocHeap">Allocate on heap</button>
      <button id="freeHeap">Free last heap</button>
      <button id="makePtr">Create pointer (in top frame)</button>
      <button id="toggleRefs">Toggle addresses</button>
      <button class="sample-btn" id="sampleRec">Show recursion (depth 4)</button>
    </div>
    <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
      <input id="varName" class="small-input" placeholder="name" />
      <input id="varVal" class="small-input" placeholder="value" />
      <input id="allocSize" class="small-input" placeholder="size" />
    </div>
    <div style="margin-top:12px">
      <div class="title">Legend</div>
      <div class="legend">Stack frames (LIFO), Heap blocks (persistent until free), Arrows show pointer references</div>
    </div>
    <div style="margin-top:12px">
      <div class="title">Console / Log</div>
      <div id="log" class="log"></div>
    </div>
  </div>

  <div class="viz">
    <div class="area">
      <div class="block stack">
        <div class="title">Stack (top at top)</div>
        <div id="stackArea"></div>
      </div>
      <div class="block heap">
        <div class="title">Heap</div>
        <div id="heapArea" style="display:flex;flex-direction:column"></div>
      </div>
    </div>

    <svg id="arrows" style="width:100%;height:120px;overflow:visible"></svg>

    <footer>
      Save and open this file in a browser. You can use the controls to simulate function calls, local variables, allocations and pointers. Use it as a teaching aid in office hours or workshop demos.
    </footer>
  </div>
</div>

<script>
// Simple in-memory model (for demonstration only)
const stack = [];
const heap = [];
let showAddrs = true;
const logEl = document.getElementById('log');
const stackArea = document.getElementById('stackArea');
const heapArea = document.getElementById('heapArea');
const svg = document.getElementById('arrows');
function addr(){ return '0x'+Math.floor(Math.random()*0xFFFFF).toString(16).padStart(5,'0'); }

function render(){
  stackArea.innerHTML=''; heapArea.innerHTML=''; svg.innerHTML='';
  // stack top is index 0 for UI (so push at front)
  stack.forEach((frame,i)=>{
    const f = document.createElement('div'); f.className='frame small';
    f.innerHTML = `<div style="display:flex;justify-content:space-between"><strong>${frame.name}</strong><span class="addr">${showAddrs?frame.bp:''}</span></div>`;
    frame.vars.forEach(v=>{
      const c=document.createElement('div'); c.className='cell';
      c.innerHTML = `<div>${v.name}</div><div>${v.repr}</div>`;
      f.appendChild(c);
    });
    stackArea.appendChild(f);
  });
  heap.forEach((b,idx)=>{
    const c=document.createElement('div'); c.className='cell';
    c.style.margin='6px';
    c.innerHTML = `<div><strong>heap[${idx}]</strong> ${b.size>1?('('+b.size+' bytes)'):''}</div><div class="addr">${showAddrs?b.addr:''}</div>`;
    heapArea.appendChild(c);
  });
  drawPointers();
}

function drawPointers(){
  // simple straight arrows from top-frame pointer cells to heap blocks
  const arrows=[];
  const topFrameEl = stackArea.children[0];
  if(!topFrameEl) return;
  const pointerEls = topFrameEl.querySelectorAll('.cell');
  pointerEls.forEach((cell,idx)=>{
    const text = cell.textContent||'';
    if(text.includes('->')){
      // parse pointer name and target index in representation like ptr->heap[0]
      const m = text.match(/heap\[(\d+)\]/);
      if(m){
        const targetIdx = Number(m[1]);
        // compute positions (approx)
        const from = cell.getBoundingClientRect();
        const toEl = heapArea.children[targetIdx];
        if(!toEl) return;
        const to = toEl.getBoundingClientRect();
        const svgRect = svg.getBoundingClientRect();
        const x1 = from.right - svgRect.left - 8;
        const y1 = from.top - svgRect.top + from.height/2;
        const x2 = to.left - svgRect.left + 8;
        const y2 = to.top - svgRect.top + to.height/2 + stackArea.getBoundingClientRect().height + 40; // fudge
        arrows.push({x1,y1,x2,y2});
      }
    }
  });
  // create defs for arrow
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  defs.innerHTML=`<marker id="arrow" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto"><path d="M0,0 L0,6 L6,3 z" fill="#60a5fa"/></marker>`;
  svg.appendChild(defs);
  arrows.forEach(a=>{
    const line = document.createElementNS('http://www.w3.org/2000/svg','path');
    const d = `M ${a.x1} ${a.y1} C ${a.x1+40} ${a.y1} ${a.x2-40} ${a.y2} ${a.x2} ${a.y2}`;
    line.setAttribute('d',d);
    line.setAttribute('class','pointer-line');
    svg.appendChild(line);
  });
}

function log(s){ const p=document.createElement('div'); p.textContent='» '+s; logEl.prepend(p); }

// Controls
document.getElementById('pushFrame').onclick = ()=>{
  const name = 'fn#'+(stack.length+1);
  const frame = {name, bp: addr(), vars:[]};
  stack.unshift(frame);
  log('Pushed frame '+name);
  render();
}
document.getElementById('popFrame').onclick = ()=>{
  if(stack.length==0){ log('Stack empty'); return; }
  const f=stack.shift(); log('Popped frame '+f.name); render();
}

document.getElementById('allocHeap').onclick = ()=>{
  const size = parseInt(document.getElementById('allocSize').value)||1;
  const block = {addr:addr(), size, id:heap.length};
  heap.push(block);
  log('Allocated heap block '+block.addr+' ('+size+' bytes)');
  render();
}

document.getElementById('freeHeap').onclick = ()=>{
  if(heap.length==0){ log('Heap empty'); return; }
  const b = heap.pop(); log('Freed heap block '+b.addr); render();
}

document.getElementById('makePtr').onclick = ()=>{
  if(stack.length==0){ log('Create a frame first'); return; }
  const name = document.getElementById('varName').value || 'ptr';
  const val = document.getElementById('varVal').value || '';
  const top = stack[0];
  if(heap.length==0){ log('No heap blocks to point to — allocating one'); document.getElementById('allocSize').value='1'; document.getElementById('allocHeap').click(); }
  const targetIdx = heap.length-1;
  const repr = `${val} -> heap[${targetIdx}]`;
  top.vars.push({name, repr});
  log('Created pointer '+name+' in '+top.name+' -> heap['+targetIdx+']');
  render();
}

document.getElementById('toggleRefs').onclick = ()=>{ showAddrs = !showAddrs; render(); }

document.getElementById('sampleRec').onclick = ()=>{
  // show a recursion of depth 4
  stack.length=0; heap.length=0; log('--- recursion sample ---');
  function rec(n){
    stack.unshift({name:'rec('+n+')', bp:addr(), vars:[{name:'n',repr:n}]});
    render();
    if(n>1){ setTimeout(()=>rec(n-1),300); }
    else{ setTimeout(()=>{ // unwind and show heap
      heap.push({addr:addr(),size:1}); render();
      setTimeout(()=>{
        while(stack.length) { const f=stack.shift(); log('return from '+f.name); render(); }
      },400);
    },400); }
  }
  rec(4);
}

// initial sample content
stack.unshift({name:'main',bp:addr(),vars:[{name:'argc',repr:1},{name:'argv',repr:'[]'}]});
render();

// responsive redraw for arrows
window.addEventListener('resize',()=>{ setTimeout(drawPointers,200); });
setInterval(drawPointers,600);
</script>
</body>
</html>
